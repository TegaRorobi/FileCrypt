**Important things to setup from the onset**
- Setting up a testing suite for the endpoints and services.
- Making use of github workflows to run these on the remote server upon merging pull requests or push actions.

> In the README file, there was something about the architecture for the project.

***Learn about the various architectures available and exactly what the one mentioned in the README implies.***

- Keep a neat and consistent folder structure throughout the entirety of this project.

- Also make sure to not make the committing process nuanced.

Write out the apps to be created and draw out the schema before even typing a line of code.



Install Django and the initial requirements.
Create a new project, and the neccessary apps.
Configure the settings.
Configure Django REST Framework.
Incorporate swagger UI and mod the necessary settings.
Create the schema.
Start with the basic endpoints.
Add authentication and authorization.
Add permissions to these endpoints.
Workout the main encryption algorithm.


## The whole point of teams, workspaces and all is sort of a role based access control for which set of people can view certain files and folders.


The encryption key is generated by the backend. Users can choose to get this encryption key either by email or by text message.

For added security, even if an encryption key is stolen, the encryption key would be configured not to work on other accounts, except the ones selected by the holder of the encryption key. So, if they share the encryption key with another account, they would have to select that account as one of the accounts to be able to use the encryption key. (This functionality could be made optional, if they don't want to have to do this anytime they share.)

## Apps that this project should have:

1. the monolithic 'main' app
2. a 'users' app for anything involving users (which might be inherited from in the main app to add useful methods and functionality for the businesses, organisations, teams, etc.)
3. another 'notifications' app for notifications, emails, text messages, etc.
4. 


## Functionality

### Single user account

- Signup
- Have an interface to access their encrypted resources (their name tags would be there, and the type of the resource, whether it's a folder, image, text, etcetera)
- Encrypt a resource which they upload.
- Get the encryption key for that resource (the encryption keys are saved for the user account and they can recover the encryptionkey for any resource in case they lost it.)
- They can send this encryption key to someone else, and they should be able to view the file(s) without having to sign up on the platform.
- The person sharing a resource should provide a link to the resource (available on the dashboard) and then the key. When the viewer clicks on the link, they have to then enter the key to have access to the resource.

# Endpoints
- `/upload/` - A user uploads an encrypted resource. User has to be authenticated to perform this action. The uploaded file is encrypted, and The In response, they get an encryption key.



When accessing an encrypted resource
I'm still working out the logic for this, but what I'll do for now is that when I get a request asking for an encrypted resourc,
I'll use the utils.EncryptionManager class to decrypt the resource, save it somewhere, and then provide a url to it where it can be viewed. Therefore, I'll return the url to the resource on my server as a response.


# Integrating a KMS For Key Management

- Take two users, User A and User B.
- User A encrypts the resource, and gets an encryption key identifier from FileCrypt.
- User B gets the key identifier from User A, and tries to decrypt the resource using that identifier.

To get the Key identifier I'll send to User A, I'll make a request to the KMS with an ID for the data I'm encrypting, perhaps
a database ID. KMS links this data ID with the Encryption key version, and KMS stores this mapping internally.

When User B tries to decrypt the resource using the key identifier, I send a request again, to the KMS. I send the
identifier and then the resource ID. KMS determines the Encyption Key version with the mapping, and provides the
correct encryption key for decrypting the resource. I use that key, decrypt the resource, and make it available to user B.

> KMS regularly rotates the actual encryption keys, and then uses a mapping to get the correct key version when I provide the resource's ID.


### Updating certain fields on models

A business has a manager account. The Business profile and the connnected User account (the "manager") together form a Business 
account. If the manager account for a business is deleted, I have set it such that the manager account field on the business would
be set to null on the Database. This is because a business might have lots of smaller structures and then it would delete
everything else peradventure the manager account was deleted by accident.
So how can a business set a new managerial account?
- One idea is for a superuser to handle it. i.e, reconnecting the business to the requested user account.
- The business account just acts as a profile, so no one can login in place of the business and set anything.
The business account can also just be deleted altogether but this time with extra caution, warnings, and notifications to
everyone in a grouping structure of that business.

#### So here's my fix for this.
I'll instead, schedule a deletion (about 7 days) and notify all members associated with the business.
I would also add functionality for the manager to stop the deletion countdown. A superuser should also be able to step in,
and stop the countdown if need be.
> This way, I don't have to worry about having a business having a null manager account. And then, there's also proper prior notification.

A similar countdown occurs when the manager transfers the managerial role to another user account.